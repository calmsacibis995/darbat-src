/* 
 * This is an automatically-generated file.
 * Source file  : test/input/inheritance.idl4
 * Output file  : -
 * Platform     : V4 Generic
 * Mapping      : CORBA C
 *
 * Generated by Magpie VERSION_REMOVED
*/

#define IDL4_OMIT_FRAME_POINTER 0 /* Unimplemented */
#define IDL4_USE_FASTCALL 0 /* Unimplemented */
#define IDL4_NEED_MALLOC 0 /* Unimplemented */
#define IDL4_API v4
#define IDL4_ARCH generic


#define MAGPIE_BYTES_PER_WORD (sizeof(L4_Word_t))

#ifdef __cplusplus
extern "C" {
#endif
#include "idl4/idl4.h"
#ifdef __cplusplus
}
#endif





#if !defined(__-__)
#define __-__




/* Interface mother */
#if !defined(_objdef___mother)
#define _objdef___mother
typedef CORBA_Object mother;
#endif // !defined(_objdef___mother)




#if !defined(_funcdef___mother_yummy_and_nutritious)
#define _funcdef___mother_yummy_and_nutritious
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_MOTHER_YUMMY_AND_NUTRITIOUS_CALL_ID (64 * (24) + 0u)

static inline void mother_yummy_and_nutritious (mother _service, int inputarg_m, int *result_m, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			int inputarg_m;
			
		} _in;
		struct {
			long _msgtag;
			int result_m;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.inputarg_m = (int)inputarg_m;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_MOTHER_YUMMY_AND_NUTRITIOUS_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*result_m = _pack._out.result_m;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___mother_yummy_and_nutritious)




/* Interface father */
#if !defined(_objdef___father)
#define _objdef___father
typedef CORBA_Object father;
#endif // !defined(_objdef___father)




#if !defined(_funcdef___father_doh)
#define _funcdef___father_doh
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_FATHER_DOH_CALL_ID (64 * (23) + 0u)

static inline void father_doh (father _service, int inputarg_f, int *result_f, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			int inputarg_f;
			
		} _in;
		struct {
			long _msgtag;
			int result_f;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.inputarg_f = (int)inputarg_f;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_FATHER_DOH_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*result_f = _pack._out.result_f;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___father_doh)




/* Interface child */
#if !defined(_objdef___child)
#define _objdef___child
typedef CORBA_Object child;
#endif // !defined(_objdef___child)




#if !defined(_funcdef___child_doh)
#define _funcdef___child_doh
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_CHILD_DOH_CALL_ID (64 * (22) + 0u)

static inline void child_doh (child _service, int inputarg_f, int *result_f, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			int inputarg_f;
			
		} _in;
		struct {
			long _msgtag;
			int result_f;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.inputarg_f = (int)inputarg_f;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_CHILD_DOH_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*result_f = _pack._out.result_f;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___child_doh)





#if !defined(_funcdef___child_yummy_and_nutritious)
#define _funcdef___child_yummy_and_nutritious
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_CHILD_YUMMY_AND_NUTRITIOUS_CALL_ID (64 * (22) + 1u)

static inline void child_yummy_and_nutritious (child _service, int inputarg_m, int *result_m, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			int inputarg_m;
			
		} _in;
		struct {
			long _msgtag;
			int result_m;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.inputarg_m = (int)inputarg_m;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_CHILD_YUMMY_AND_NUTRITIOUS_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*result_m = _pack._out.result_m;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___child_yummy_and_nutritious)





#if !defined(_funcdef___child_eat_my_shorts)
#define _funcdef___child_eat_my_shorts
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_CHILD_EAT_MY_SHORTS_CALL_ID (64 * (22) + 2u)

static inline void child_eat_my_shorts (child _service, int inputarg_c, int *result_c, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			int inputarg_c;
			
		} _in;
		struct {
			long _msgtag;
			int result_c;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.inputarg_c = (int)inputarg_c;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_CHILD_EAT_MY_SHORTS_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*result_c = _pack._out.result_c;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___child_eat_my_shorts)





#endif //__-__
