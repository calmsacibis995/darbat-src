/* 
 * This is an automatically-generated file.
 * Source file  : test/input/iguana.idl4
 * Output file  : -
 * Platform     : V4 Generic
 * Mapping      : CORBA C
 *
 * Generated by Magpie VERSION_REMOVED
*/

#define IDL4_OMIT_FRAME_POINTER 0 /* Unimplemented */
#define IDL4_USE_FASTCALL 0 /* Unimplemented */
#define IDL4_NEED_MALLOC 0 /* Unimplemented */
#define IDL4_API v4
#define IDL4_ARCH generic


#define MAGPIE_BYTES_PER_WORD (sizeof(L4_Word_t))

#ifdef __cplusplus
extern "C" {
#endif
#include "idl4/idl4.h"
#ifdef __cplusplus
}
#endif



#include "l4/types.h"

#include "iguana/types.h"

#include "stdint.h"

#include "stddef.h"



#if !defined(__-__)
#define __-__




/* Interface iguana_ex */
#if !defined(_objdef___iguana_ex)
#define _objdef___iguana_ex
typedef CORBA_Object iguana_ex;
#endif // !defined(_objdef___iguana_ex)




#if !defined(_funcdef___iguana_ex_pagefault)
#define _funcdef___iguana_ex_pagefault
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_EX_PAGEFAULT_CALL_ID (64 * (21) + 0u)

static inline void iguana_ex_pagefault (iguana_ex _service, uintptr_t addr, uintptr_t ip, uintptr_t priv, idl4_fpage_t *fp, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			uintptr_t addr;
			uintptr_t ip;
			uintptr_t priv;
			
		} _in;
		struct {
			long _msgtag;
			idl4_fpage_t fp;
			
		} _out;
	} _pack;
	/* marshal */
	L4_Accept(_env->_rcv_window);
		
		
		
		_pack._in.addr = (uintptr_t)addr;
	
		
		
		_pack._in.ip = (uintptr_t)ip;
	
		
		
		_pack._in.priv = (uintptr_t)priv;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_EX_PAGEFAULT_CALL_ID+(priv & 7)) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	L4_Accept(_env->_rcv_window);
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	L4_Accept(L4_UntypedWordsAcceptor);

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*fp = _pack._out.fp;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_ex_pagefault)




/* Interface iguana_pd */
#if !defined(_objdef___iguana_pd)
#define _objdef___iguana_pd
typedef CORBA_Object iguana_pd;
#endif // !defined(_objdef___iguana_pd)




#if !defined(_funcdef___iguana_pd_mypd)
#define _funcdef___iguana_pd_mypd
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_PD_MYPD_CALL_ID (64 * (22) + 0u)

static inline objref_t iguana_pd_mypd (iguana_pd _service, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			
		} _in;
		struct {
			long _msgtag;
			objref_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_PD_MYPD_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_pd_mypd)





#if !defined(_funcdef___iguana_pd_create_memsection)
#define _funcdef___iguana_pd_create_memsection
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_PD_CREATE_MEMSECTION_CALL_ID (64 * (22) + 1u)

static inline cap_t iguana_pd_create_memsection (iguana_pd _service, pd_ref_t pd, uintptr_t size, uintptr_t *base, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			pd_ref_t pd;
			uintptr_t size;
			
		} _in;
		struct {
			long _msgtag;
			uintptr_t base;
			cap_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.pd = (pd_ref_t)pd;
	
		
		
		_pack._in.size = (uintptr_t)size;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_PD_CREATE_MEMSECTION_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*base = _pack._out.base;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_pd_create_memsection)





#if !defined(_funcdef___iguana_pd_create_pd)
#define _funcdef___iguana_pd_create_pd
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_PD_CREATE_PD_CALL_ID (64 * (22) + 2u)

static inline cap_t iguana_pd_create_pd (iguana_pd _service, pd_ref_t pd, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			pd_ref_t pd;
			
		} _in;
		struct {
			long _msgtag;
			cap_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.pd = (pd_ref_t)pd;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_PD_CREATE_PD_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_pd_create_pd)





#if !defined(_funcdef___iguana_pd_create_thread)
#define _funcdef___iguana_pd_create_thread
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_PD_CREATE_THREAD_CALL_ID (64 * (22) + 3u)

static inline cap_t iguana_pd_create_thread (iguana_pd _service, pd_ref_t pd, L4_ThreadId_t *l4_id, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			pd_ref_t pd;
			
		} _in;
		struct {
			long _msgtag;
			L4_ThreadId_t l4_id;
			cap_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.pd = (pd_ref_t)pd;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_PD_CREATE_THREAD_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*l4_id = _pack._out.l4_id;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_pd_create_thread)





#if !defined(_funcdef___iguana_pd_create_eas)
#define _funcdef___iguana_pd_create_eas
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_PD_CREATE_EAS_CALL_ID (64 * (22) + 4u)

static inline cap_t iguana_pd_create_eas (iguana_pd _service, pd_ref_t pd, L4_Fpage_t *kip, L4_Fpage_t *utcb, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			pd_ref_t pd;
			L4_Fpage_t kip;
			L4_Fpage_t utcb;
			
		} _in;
		struct {
			long _msgtag;
			cap_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.pd = (pd_ref_t)pd;
	
		
		
		_pack._in.kip = *(L4_Fpage_t*)kip;
	
		
		
		_pack._in.utcb = *(L4_Fpage_t*)utcb;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_PD_CREATE_EAS_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_pd_create_eas)





#if !defined(_funcdef___iguana_pd_create_session)
#define _funcdef___iguana_pd_create_session
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_PD_CREATE_SESSION_CALL_ID (64 * (22) + 5u)

static inline cap_t iguana_pd_create_session (iguana_pd _service, pd_ref_t pd, thread_ref_t client, thread_ref_t server, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			pd_ref_t pd;
			thread_ref_t client;
			thread_ref_t server;
			
		} _in;
		struct {
			long _msgtag;
			cap_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.pd = (pd_ref_t)pd;
	
		
		
		_pack._in.client = (thread_ref_t)client;
	
		
		
		_pack._in.server = (thread_ref_t)server;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_PD_CREATE_SESSION_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_pd_create_session)





#if !defined(_funcdef___iguana_pd_set_callback)
#define _funcdef___iguana_pd_set_callback
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_PD_SET_CALLBACK_CALL_ID (64 * (22) + 6u)

static inline void iguana_pd_set_callback (iguana_pd _service, pd_ref_t pd, memsection_ref_t callback_buffer, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			pd_ref_t pd;
			memsection_ref_t callback_buffer;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.pd = (pd_ref_t)pd;
	
		
		
		_pack._in.callback_buffer = (memsection_ref_t)callback_buffer;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_PD_SET_CALLBACK_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_pd_set_callback)





#if !defined(_funcdef___iguana_pd_delete)
#define _funcdef___iguana_pd_delete
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_PD_DELETE_CALL_ID (64 * (22) + 7u)

static inline void iguana_pd_delete (iguana_pd _service, pd_ref_t pd, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			pd_ref_t pd;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.pd = (pd_ref_t)pd;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_PD_DELETE_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_pd_delete)




/* Interface iguana_eas */
#if !defined(_objdef___iguana_eas)
#define _objdef___iguana_eas
typedef CORBA_Object iguana_eas;
#endif // !defined(_objdef___iguana_eas)




#if !defined(_funcdef___iguana_eas_create_thread)
#define _funcdef___iguana_eas_create_thread
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_EAS_CREATE_THREAD_CALL_ID (64 * (23) + 0u)

static inline cap_t iguana_eas_create_thread (iguana_eas _service, eas_ref_t eas, L4_ThreadId_t *start, L4_ThreadId_t *pager, L4_ThreadId_t *scheduler, uintptr_t utcb, L4_ThreadId_t *l4_id, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			eas_ref_t eas;
			L4_ThreadId_t start;
			L4_ThreadId_t pager;
			L4_ThreadId_t scheduler;
			uintptr_t utcb;
			
		} _in;
		struct {
			long _msgtag;
			L4_ThreadId_t l4_id;
			cap_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.eas = (eas_ref_t)eas;
	
		
		
		_pack._in.start = *(L4_ThreadId_t*)start;
	
		
		
		_pack._in.pager = *(L4_ThreadId_t*)pager;
	
		
		
		_pack._in.scheduler = *(L4_ThreadId_t*)scheduler;
	
		
		
		_pack._in.utcb = (uintptr_t)utcb;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_EAS_CREATE_THREAD_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*l4_id = _pack._out.l4_id;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_eas_create_thread)





#if !defined(_funcdef___iguana_eas_delete)
#define _funcdef___iguana_eas_delete
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_EAS_DELETE_CALL_ID (64 * (23) + 1u)

static inline void iguana_eas_delete (iguana_eas _service, eas_ref_t eas, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			eas_ref_t eas;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.eas = (eas_ref_t)eas;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_EAS_DELETE_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_eas_delete)




/* Interface iguana_thread */
#if !defined(_objdef___iguana_thread)
#define _objdef___iguana_thread
typedef CORBA_Object iguana_thread;
#endif // !defined(_objdef___iguana_thread)




#if !defined(_funcdef___iguana_thread_id)
#define _funcdef___iguana_thread_id
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_ID_CALL_ID (64 * (24) + 0u)

static inline thread_ref_t iguana_thread_id (iguana_thread _service, L4_ThreadId_t *thread, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			L4_ThreadId_t thread;
			
		} _in;
		struct {
			long _msgtag;
			thread_ref_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thread = *(L4_ThreadId_t*)thread;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_ID_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_thread_id)





#if !defined(_funcdef___iguana_thread_l4id)
#define _funcdef___iguana_thread_l4id
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_L4ID_CALL_ID (64 * (24) + 1u)

static inline L4_ThreadId_t iguana_thread_l4id (iguana_thread _service, thread_ref_t thread, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			thread_ref_t thread;
			
		} _in;
		struct {
			long _msgtag;
			L4_ThreadId_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thread = (thread_ref_t)thread;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_L4ID_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_thread_l4id)





#if !defined(_funcdef___iguana_thread_start)
#define _funcdef___iguana_thread_start
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_START_CALL_ID (64 * (24) + 2u)

static inline void iguana_thread_start (iguana_thread _service, thread_ref_t thread, uintptr_t ip, uintptr_t sp, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			thread_ref_t thread;
			uintptr_t ip;
			uintptr_t sp;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thread = (thread_ref_t)thread;
	
		
		
		_pack._in.ip = (uintptr_t)ip;
	
		
		
		_pack._in.sp = (uintptr_t)sp;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_START_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_thread_start)





#if !defined(_funcdef___iguana_thread_delete)
#define _funcdef___iguana_thread_delete
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_DELETE_CALL_ID (64 * (24) + 3u)

static inline void iguana_thread_delete (iguana_thread _service, thread_ref_t thread, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			thread_ref_t thread;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thread = (thread_ref_t)thread;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_DELETE_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_thread_delete)




/* Interface iguana_hardware */
#if !defined(_objdef___iguana_hardware)
#define _objdef___iguana_hardware
typedef CORBA_Object iguana_hardware;
#endif // !defined(_objdef___iguana_hardware)




#if !defined(_funcdef___iguana_hardware_register_interrupt)
#define _funcdef___iguana_hardware_register_interrupt
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_HARDWARE_REGISTER_INTERRUPT_CALL_ID (64 * (25) + 0u)

static inline int iguana_hardware_register_interrupt (iguana_hardware _service, hw_ref_t hardware, L4_ThreadId_t *handler, int interrupt, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			hw_ref_t hardware;
			L4_ThreadId_t handler;
			int interrupt;
			
		} _in;
		struct {
			long _msgtag;
			int __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.hardware = (hw_ref_t)hardware;
	
		
		
		_pack._in.handler = *(L4_ThreadId_t*)handler;
	
		
		
		_pack._in.interrupt = (int)interrupt;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_HARDWARE_REGISTER_INTERRUPT_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_hardware_register_interrupt)





#if !defined(_funcdef___iguana_hardware_back_memsection)
#define _funcdef___iguana_hardware_back_memsection
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_HARDWARE_BACK_MEMSECTION_CALL_ID (64 * (25) + 1u)

static inline int iguana_hardware_back_memsection (iguana_hardware _service, hw_ref_t hardware, memsection_ref_t memsection, uintptr_t paddr, uintptr_t attributes, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			hw_ref_t hardware;
			memsection_ref_t memsection;
			uintptr_t paddr;
			uintptr_t attributes;
			
		} _in;
		struct {
			long _msgtag;
			int __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.hardware = (hw_ref_t)hardware;
	
		
		
		_pack._in.memsection = (memsection_ref_t)memsection;
	
		
		
		_pack._in.paddr = (uintptr_t)paddr;
	
		
		
		_pack._in.attributes = (uintptr_t)attributes;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_HARDWARE_BACK_MEMSECTION_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_hardware_back_memsection)




/* Interface iguana_memsection */
#if !defined(_objdef___iguana_memsection)
#define _objdef___iguana_memsection
typedef CORBA_Object iguana_memsection;
#endif // !defined(_objdef___iguana_memsection)




#if !defined(_funcdef___iguana_memsection_register_server)
#define _funcdef___iguana_memsection_register_server
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_MEMSECTION_REGISTER_SERVER_CALL_ID (64 * (26) + 0u)

static inline int iguana_memsection_register_server (iguana_memsection _service, memsection_ref_t memsection, thread_ref_t thread, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			memsection_ref_t memsection;
			thread_ref_t thread;
			
		} _in;
		struct {
			long _msgtag;
			int __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.memsection = (memsection_ref_t)memsection;
	
		
		
		_pack._in.thread = (thread_ref_t)thread;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_MEMSECTION_REGISTER_SERVER_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_memsection_register_server)





#if !defined(_funcdef___iguana_memsection_lookup)
#define _funcdef___iguana_memsection_lookup
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_MEMSECTION_LOOKUP_CALL_ID (64 * (26) + 1u)

static inline memsection_ref_t iguana_memsection_lookup (iguana_memsection _service, uintptr_t address, thread_ref_t *server, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			uintptr_t address;
			
		} _in;
		struct {
			long _msgtag;
			thread_ref_t server;
			memsection_ref_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.address = (uintptr_t)address;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_MEMSECTION_LOOKUP_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*server = _pack._out.server;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_memsection_lookup)





#if !defined(_funcdef___iguana_memsection_delete)
#define _funcdef___iguana_memsection_delete
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_MEMSECTION_DELETE_CALL_ID (64 * (26) + 2u)

static inline void iguana_memsection_delete (iguana_memsection _service, memsection_ref_t thread, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			memsection_ref_t thread;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thread = (memsection_ref_t)thread;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_MEMSECTION_DELETE_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_memsection_delete)




/* Interface iguana_session */
#if !defined(_objdef___iguana_session)
#define _objdef___iguana_session
typedef CORBA_Object iguana_session;
#endif // !defined(_objdef___iguana_session)




#if !defined(_funcdef___iguana_session_delete)
#define _funcdef___iguana_session_delete
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_SESSION_DELETE_CALL_ID (64 * (27) + 0u)

static inline void iguana_session_delete (iguana_session _service, session_ref_t session, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			session_ref_t session;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.session = (session_ref_t)session;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_SESSION_DELETE_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_session_delete)





#if !defined(_funcdef___iguana_session_add_buffer)
#define _funcdef___iguana_session_add_buffer
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_SESSION_ADD_BUFFER_CALL_ID (64 * (27) + 1u)

static inline void iguana_session_add_buffer (iguana_session _service, session_ref_t session, objref_t call_buf, objref_t return_buf, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			session_ref_t session;
			objref_t call_buf;
			objref_t return_buf;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.session = (session_ref_t)session;
	
		
		
		_pack._in.call_buf = (objref_t)call_buf;
	
		
		
		_pack._in.return_buf = (objref_t)return_buf;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_SESSION_ADD_BUFFER_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_session_add_buffer)





#endif //__-__
