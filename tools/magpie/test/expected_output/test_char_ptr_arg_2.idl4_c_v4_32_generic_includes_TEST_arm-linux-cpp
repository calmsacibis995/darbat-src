/* 
 * This is an automatically-generated file.
 * Source file  : test/input/char_ptr_arg_2.idl4
 * Output file  : -
 * Platform     : V4 Generic
 * Mapping      : CORBA C
 *
 * Generated by Magpie VERSION_REMOVED
*/

#define IDL4_OMIT_FRAME_POINTER 0 /* Unimplemented */
#define IDL4_USE_FASTCALL 0 /* Unimplemented */
#define IDL4_NEED_MALLOC 0 /* Unimplemented */
#define IDL4_API v4
#define IDL4_ARCH generic


#define MAGPIE_BYTES_PER_WORD (sizeof(L4_Word_t))

#ifdef __cplusplus
extern "C" {
#endif
#include "idl4/idl4.h"
#ifdef __cplusplus
}
#endif



#include "char_ptr_arg_2.h"



#if !defined(__-__)
#define __-__




/* Interface iguana_thread */
#if !defined(_objdef___iguana_thread)
#define _objdef___iguana_thread
typedef CORBA_Object iguana_thread;
#endif // !defined(_objdef___iguana_thread)




#if !defined(_funcdef___iguana_thread_id)
#define _funcdef___iguana_thread_id
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_ID_CALL_ID (64 * (24) + 0u)

static inline thread_ref_t iguana_thread_id (iguana_thread _service, L4_ThreadId_t thread, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			L4_ThreadId_t thread;
			
		} _in;
		struct {
			long _msgtag;
			thread_ref_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thread = (L4_ThreadId_t)thread;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_ID_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_thread_id)





#if !defined(_funcdef___iguana_thread_l4id)
#define _funcdef___iguana_thread_l4id
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_L4ID_CALL_ID (64 * (24) + 1u)

static inline L4_ThreadId_t iguana_thread_l4id (iguana_thread _service, thread_ref_t thread, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			thread_ref_t thread;
			
		} _in;
		struct {
			long _msgtag;
			L4_ThreadId_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thread = (thread_ref_t)thread;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_L4ID_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_thread_l4id)





#if !defined(_funcdef___iguana_thread_set_handle)
#define _funcdef___iguana_thread_set_handle
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_SET_HANDLE_CALL_ID (64 * (24) + 2u)

static inline void iguana_thread_set_handle (iguana_thread _service, L4_ThreadId_t thrd_id, char *handle, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			L4_ThreadId_t thrd_id;
			char *handle;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thrd_id = (L4_ThreadId_t)thrd_id;
	
		
		
		_pack._in.handle = (char*)handle;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_SET_HANDLE_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_thread_set_handle)





#if !defined(_funcdef___iguana_thread_getId_from_handle)
#define _funcdef___iguana_thread_getId_from_handle
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_GETID_FROM_HANDLE_CALL_ID (64 * (24) + 3u)

static inline L4_ThreadId_t iguana_thread_getId_from_handle (iguana_thread _service, char *handle, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			char *handle;
			
		} _in;
		struct {
			long _msgtag;
			L4_ThreadId_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.handle = (char*)handle;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_GETID_FROM_HANDLE_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_thread_getId_from_handle)





#if !defined(_funcdef___iguana_thread_clr_handle)
#define _funcdef___iguana_thread_clr_handle
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_CLR_HANDLE_CALL_ID (64 * (24) + 4u)

static inline int iguana_thread_clr_handle (iguana_thread _service, L4_ThreadId_t thrd_id, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			L4_ThreadId_t thrd_id;
			
		} _in;
		struct {
			long _msgtag;
			int __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thrd_id = (L4_ThreadId_t)thrd_id;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_CLR_HANDLE_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	

}
#endif // !defined(_funcdef___iguana_thread_clr_handle)





#if !defined(_funcdef___iguana_thread_start)
#define _funcdef___iguana_thread_start
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_START_CALL_ID (64 * (24) + 5u)

static inline void iguana_thread_start (iguana_thread _service, thread_ref_t thread, uintptr_t ip, uintptr_t sp, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			thread_ref_t thread;
			uintptr_t ip;
			uintptr_t sp;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thread = (thread_ref_t)thread;
	
		
		
		_pack._in.ip = (uintptr_t)ip;
	
		
		
		_pack._in.sp = (uintptr_t)sp;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_START_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_thread_start)





#if !defined(_funcdef___iguana_thread_delete)
#define _funcdef___iguana_thread_delete
/* the *_CALL_ID is defined as 64 * the interface ID, plus the function number.
 * This restricts us to 64 functions per interface.
*/
#define _MAGPIE_IGUANA_THREAD_DELETE_CALL_ID (64 * (24) + 6u)

static inline void iguana_thread_delete (iguana_thread _service, thread_ref_t thread, CORBA_Environment *_env)
{



	long _exception;
	L4_MsgTag_t _result;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			thread_ref_t thread;
			
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.thread = (thread_ref_t)thread;
	

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_THREAD_DELETE_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
	
	_result = L4_Call(_service);
	
	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	

}
#endif // !defined(_funcdef___iguana_thread_delete)





#endif //__-__
