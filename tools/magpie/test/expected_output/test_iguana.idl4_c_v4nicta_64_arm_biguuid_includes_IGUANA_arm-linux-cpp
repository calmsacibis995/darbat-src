/* 
 * This is an automatically-generated file.
 * Source file  : test/input/iguana.idl4
 * Output file  : -
 * Platform     : V4 ARM (big UUID)
 * Mapping      : CORBA C
 *
 * Generated by Magpie VERSION_REMOVED
*/

#define IDL4_OMIT_FRAME_POINTER 0 /* Unimplemented */
#define IDL4_USE_FASTCALL 0 /* Unimplemented */
#define IDL4_NEED_MALLOC 0 /* Unimplemented */
#define IDL4_API v4
#define IDL4_ARCH arm_biguuid


#define MAGPIE_BYTES_PER_WORD (sizeof(L4_Word_t))

/* This from $pistachio/include/l4/arm/syscalls.h */
#define MAGPIE__L4_SYSCALL                   \
        "str    fp,     [sp, #-4]! \n" \
        "mov    lr,     pc         \n" \
        "mov    pc,     ip         \n" \
        "ldr    fp,     [sp],   #4 \n"

#ifdef __cplusplus
extern "C" {
#endif
#include "idl4biguuid_arm/idl4.h"
#ifdef __cplusplus
}
#endif



#include "l4/types.h"

#include "iguana/types.h"

#include "stdint.h"

#include "stddef.h"



#if !defined(__-__)
#define __-__




/* Interface iguana_ex */
#if !defined(_objdef___iguana_ex)
#define _objdef___iguana_ex
typedef CORBA_Object iguana_ex;
#endif // !defined(_objdef___iguana_ex)




#if !defined(_funcdef___iguana_ex_pagefault)
#define _funcdef___iguana_ex_pagefault
/* Biguuid generic code: _MAGPIE_IGUANA_EX_PAGEFAULT_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_EX_PAGEFAULT_CALL_ID (0u)

static inline void iguana_ex_pagefault (iguana_ex _service, uintptr_t addr, uintptr_t ip, uintptr_t priv, idl4_fpage_t *fp, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	register L4_Word_t r_mr4 asm("r7"); 
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_EX_PAGEFAULT_arm_buf {
		struct {
			long _msgtag;
			
			uintptr_t addr;
			uintptr_t ip;
			uintptr_t priv;
		} _in;
		struct {
			long _msgtag;
			idl4_fpage_t fp;
			
		} _out;
	} __MAGPIE_IGUANA_EX_PAGEFAULT_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_EX_PAGEFAULT_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (3 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_EX_PAGEFAULT_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (2) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_EX_PAGEFAULT_CALL_ID+(priv & 7)) << 16) + 3 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 21;

	r_mr2 =  ((L4_Word_t)addr);
	

	r_mr3 =  ((L4_Word_t)ip);
	

	r_mr4 =  ((L4_Word_t)priv);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1), "=r" (r_mr2),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3), "r" (r_mr4),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	*fp = (idl4_fpage_t)r_mr1;
	
	
	


}
#endif // !defined(_funcdef___iguana_ex_pagefault)




/* Interface iguana_pd */
#if !defined(_objdef___iguana_pd)
#define _objdef___iguana_pd
typedef CORBA_Object iguana_pd;
#endif // !defined(_objdef___iguana_pd)




#if !defined(_funcdef___iguana_pd_mypd)
#define _funcdef___iguana_pd_mypd
/* Biguuid generic code: _MAGPIE_IGUANA_PD_MYPD_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_PD_MYPD_CALL_ID (0u)

static inline objref_t iguana_pd_mypd (iguana_pd _service, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_PD_MYPD_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
		} _in;
		struct {
			long _msgtag;
			objref_t __retval;
		} _out;
	} __MAGPIE_IGUANA_PD_MYPD_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_PD_MYPD_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (0 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_PD_MYPD_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (1) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_PD_MYPD_CALL_ID) << 16) + 0 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 22;
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r5", "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	/* Result fits in a single register. */
	return (objref_t)r_mr1;
	
	


}
#endif // !defined(_funcdef___iguana_pd_mypd)





#if !defined(_funcdef___iguana_pd_create_memsection)
#define _funcdef___iguana_pd_create_memsection
/* Biguuid generic code: _MAGPIE_IGUANA_PD_CREATE_MEMSECTION_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_PD_CREATE_MEMSECTION_CALL_ID (1u)

static inline cap_t iguana_pd_create_memsection (iguana_pd _service, pd_ref_t pd, uintptr_t size, uintptr_t *base, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	cap_t __return; 

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_PD_CREATE_MEMSECTION_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			pd_ref_t pd;
			uintptr_t size;
		} _in;
		struct {
			long _msgtag;
			uintptr_t base;
			cap_t __retval;
		} _out;
	} __MAGPIE_IGUANA_PD_CREATE_MEMSECTION_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_PD_CREATE_MEMSECTION_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (2 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_PD_CREATE_MEMSECTION_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (3) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_PD_CREATE_MEMSECTION_CALL_ID) << 16) + 2 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 22;

	r_mr2 =  ((L4_Word_t)pd);
	

	r_mr3 =  ((L4_Word_t)size);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1), "=r" (r_mr2), "=r" (r_mr3),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	*base = (uintptr_t)r_mr1;
	
	
	
	/* Return result (which doesn't fit in a single register)*/
	
		*( ((L4_Word_t *)(void *)&__return) + 0) = r_mr2;
	
		*( ((L4_Word_t *)(void *)&__return) + 1) = r_mr3;
	
	return __return;
	


}
#endif // !defined(_funcdef___iguana_pd_create_memsection)





#if !defined(_funcdef___iguana_pd_create_pd)
#define _funcdef___iguana_pd_create_pd
/* Biguuid generic code: _MAGPIE_IGUANA_PD_CREATE_PD_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_PD_CREATE_PD_CALL_ID (2u)

static inline cap_t iguana_pd_create_pd (iguana_pd _service, pd_ref_t pd, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	cap_t __return; 

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_PD_CREATE_PD_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			pd_ref_t pd;
		} _in;
		struct {
			long _msgtag;
			cap_t __retval;
		} _out;
	} __MAGPIE_IGUANA_PD_CREATE_PD_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_PD_CREATE_PD_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_PD_CREATE_PD_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (2) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_PD_CREATE_PD_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 22;

	r_mr2 =  ((L4_Word_t)pd);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1), "=r" (r_mr2),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	
	/* Return result (which doesn't fit in a single register)*/
	
		*( ((L4_Word_t *)(void *)&__return) + 0) = r_mr1;
	
		*( ((L4_Word_t *)(void *)&__return) + 1) = r_mr2;
	
	return __return;
	


}
#endif // !defined(_funcdef___iguana_pd_create_pd)





#if !defined(_funcdef___iguana_pd_create_thread)
#define _funcdef___iguana_pd_create_thread
/* Biguuid generic code: _MAGPIE_IGUANA_PD_CREATE_THREAD_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_PD_CREATE_THREAD_CALL_ID (3u)

static inline cap_t iguana_pd_create_thread (iguana_pd _service, pd_ref_t pd, L4_ThreadId_t *l4_id, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	cap_t __return; 

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_PD_CREATE_THREAD_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			pd_ref_t pd;
		} _in;
		struct {
			long _msgtag;
			L4_ThreadId_t l4_id;
			cap_t __retval;
		} _out;
	} __MAGPIE_IGUANA_PD_CREATE_THREAD_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_PD_CREATE_THREAD_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_PD_CREATE_THREAD_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (3) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_PD_CREATE_THREAD_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 22;

	r_mr2 =  ((L4_Word_t)pd);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1), "=r" (r_mr2), "=r" (r_mr3),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	*l4_id = (L4_ThreadId_t)r_mr1;
	
	
	
	/* Return result (which doesn't fit in a single register)*/
	
		*( ((L4_Word_t *)(void *)&__return) + 0) = r_mr2;
	
		*( ((L4_Word_t *)(void *)&__return) + 1) = r_mr3;
	
	return __return;
	


}
#endif // !defined(_funcdef___iguana_pd_create_thread)





#if !defined(_funcdef___iguana_pd_create_eas)
#define _funcdef___iguana_pd_create_eas
/* Biguuid generic code: _MAGPIE_IGUANA_PD_CREATE_EAS_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_PD_CREATE_EAS_CALL_ID (4u)

static inline cap_t iguana_pd_create_eas (iguana_pd _service, pd_ref_t pd, L4_Fpage_t *kip, L4_Fpage_t *utcb, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	register L4_Word_t r_mr4 asm("r7"); 
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	cap_t __return; 

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_PD_CREATE_EAS_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			pd_ref_t pd;
			L4_Fpage_t kip;
			L4_Fpage_t utcb;
		} _in;
		struct {
			long _msgtag;
			cap_t __retval;
		} _out;
	} __MAGPIE_IGUANA_PD_CREATE_EAS_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_PD_CREATE_EAS_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (3 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_PD_CREATE_EAS_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (2) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_PD_CREATE_EAS_CALL_ID) << 16) + 3 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 22;

	r_mr2 =  ((L4_Word_t)pd);
	

	r_mr3 =  *((L4_Word_t*)kip);
	

	r_mr4 =  *((L4_Word_t*)utcb);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1), "=r" (r_mr2),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3), "r" (r_mr4),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	
	/* Return result (which doesn't fit in a single register)*/
	
		*( ((L4_Word_t *)(void *)&__return) + 0) = r_mr1;
	
		*( ((L4_Word_t *)(void *)&__return) + 1) = r_mr2;
	
	return __return;
	


}
#endif // !defined(_funcdef___iguana_pd_create_eas)





#if !defined(_funcdef___iguana_pd_create_session)
#define _funcdef___iguana_pd_create_session
/* Biguuid generic code: _MAGPIE_IGUANA_PD_CREATE_SESSION_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_PD_CREATE_SESSION_CALL_ID (5u)

static inline cap_t iguana_pd_create_session (iguana_pd _service, pd_ref_t pd, thread_ref_t client, thread_ref_t server, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	register L4_Word_t r_mr4 asm("r7"); 
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	cap_t __return; 

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_PD_CREATE_SESSION_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			pd_ref_t pd;
			thread_ref_t client;
			thread_ref_t server;
		} _in;
		struct {
			long _msgtag;
			cap_t __retval;
		} _out;
	} __MAGPIE_IGUANA_PD_CREATE_SESSION_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_PD_CREATE_SESSION_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (3 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_PD_CREATE_SESSION_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (2) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_PD_CREATE_SESSION_CALL_ID) << 16) + 3 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 22;

	r_mr2 =  ((L4_Word_t)pd);
	

	r_mr3 =  ((L4_Word_t)client);
	

	r_mr4 =  ((L4_Word_t)server);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1), "=r" (r_mr2),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3), "r" (r_mr4),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	
	/* Return result (which doesn't fit in a single register)*/
	
		*( ((L4_Word_t *)(void *)&__return) + 0) = r_mr1;
	
		*( ((L4_Word_t *)(void *)&__return) + 1) = r_mr2;
	
	return __return;
	


}
#endif // !defined(_funcdef___iguana_pd_create_session)





#if !defined(_funcdef___iguana_pd_set_callback)
#define _funcdef___iguana_pd_set_callback
/* Biguuid generic code: _MAGPIE_IGUANA_PD_SET_CALLBACK_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_PD_SET_CALLBACK_CALL_ID (6u)

static inline void iguana_pd_set_callback (iguana_pd _service, pd_ref_t pd, memsection_ref_t callback_buffer, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_PD_SET_CALLBACK_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			pd_ref_t pd;
			memsection_ref_t callback_buffer;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_PD_SET_CALLBACK_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_PD_SET_CALLBACK_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (2 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_PD_SET_CALLBACK_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_PD_SET_CALLBACK_CALL_ID) << 16) + 2 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 22;

	r_mr2 =  ((L4_Word_t)pd);
	

	r_mr3 =  ((L4_Word_t)callback_buffer);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_pd_set_callback)





#if !defined(_funcdef___iguana_pd_delete)
#define _funcdef___iguana_pd_delete
/* Biguuid generic code: _MAGPIE_IGUANA_PD_DELETE_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_PD_DELETE_CALL_ID (7u)

static inline void iguana_pd_delete (iguana_pd _service, pd_ref_t pd, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_PD_DELETE_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			pd_ref_t pd;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_PD_DELETE_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_PD_DELETE_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_PD_DELETE_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_PD_DELETE_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 22;

	r_mr2 =  ((L4_Word_t)pd);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_pd_delete)




/* Interface iguana_eas */
#if !defined(_objdef___iguana_eas)
#define _objdef___iguana_eas
typedef CORBA_Object iguana_eas;
#endif // !defined(_objdef___iguana_eas)




#if !defined(_funcdef___iguana_eas_create_thread)
#define _funcdef___iguana_eas_create_thread
/* Biguuid generic code: _MAGPIE_IGUANA_EAS_CREATE_THREAD_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_EAS_CREATE_THREAD_CALL_ID (0u)

static inline cap_t iguana_eas_create_thread (iguana_eas _service, eas_ref_t eas, L4_ThreadId_t *start, L4_ThreadId_t *pager, L4_ThreadId_t *scheduler, uintptr_t utcb, L4_ThreadId_t *l4_id, CORBA_Environment *_env)
{





	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			long _uuid;
			eas_ref_t eas;
			L4_ThreadId_t start;
			L4_ThreadId_t pager;
			L4_ThreadId_t scheduler;
			uintptr_t utcb;
			
		} _in;
		struct {
			long _msgtag;
			L4_ThreadId_t l4_id;
			cap_t __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.eas = (eas_ref_t)eas;
	
		
		
		_pack._in.start = *(L4_ThreadId_t*)start;
	
		
		
		_pack._in.pager = *(L4_ThreadId_t*)pager;
	
		
		
		_pack._in.scheduler = *(L4_ThreadId_t*)scheduler;
	
		
		
		_pack._in.utcb = (uintptr_t)utcb;
	
	_pack._in._uuid = 23;

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_EAS_CREATE_THREAD_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	if (IDL4_EXPECT_TRUE((L4_IpcSucceeded(_result)) && !_exception)) {
		/* unmarshal */
		
			*l4_id = _pack._out.l4_id;
		
	}
	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	




}
#endif // !defined(_funcdef___iguana_eas_create_thread)





#if !defined(_funcdef___iguana_eas_delete)
#define _funcdef___iguana_eas_delete
/* Biguuid generic code: _MAGPIE_IGUANA_EAS_DELETE_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_EAS_DELETE_CALL_ID (1u)

static inline void iguana_eas_delete (iguana_eas _service, eas_ref_t eas, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_EAS_DELETE_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			eas_ref_t eas;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_EAS_DELETE_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_EAS_DELETE_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_EAS_DELETE_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_EAS_DELETE_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 23;

	r_mr2 =  ((L4_Word_t)eas);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_eas_delete)




/* Interface iguana_thread */
#if !defined(_objdef___iguana_thread)
#define _objdef___iguana_thread
typedef CORBA_Object iguana_thread;
#endif // !defined(_objdef___iguana_thread)




#if !defined(_funcdef___iguana_thread_id)
#define _funcdef___iguana_thread_id
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_ID_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_ID_CALL_ID (0u)

static inline thread_ref_t iguana_thread_id (iguana_thread _service, L4_ThreadId_t *thread, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_ID_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			L4_ThreadId_t thread;
		} _in;
		struct {
			long _msgtag;
			thread_ref_t __retval;
		} _out;
	} __MAGPIE_IGUANA_THREAD_ID_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_ID_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_ID_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (1) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_ID_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  *((L4_Word_t*)thread);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	/* Result fits in a single register. */
	return (thread_ref_t)r_mr1;
	
	


}
#endif // !defined(_funcdef___iguana_thread_id)





#if !defined(_funcdef___iguana_thread_l4id)
#define _funcdef___iguana_thread_l4id
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_L4ID_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_L4ID_CALL_ID (1u)

static inline L4_ThreadId_t iguana_thread_l4id (iguana_thread _service, thread_ref_t thread, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_L4ID_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			thread_ref_t thread;
		} _in;
		struct {
			long _msgtag;
			L4_ThreadId_t __retval;
		} _out;
	} __MAGPIE_IGUANA_THREAD_L4ID_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_L4ID_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_L4ID_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (1) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_L4ID_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  ((L4_Word_t)thread);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	/* Result fits in a single register. */
	return (L4_ThreadId_t)r_mr1;
	
	


}
#endif // !defined(_funcdef___iguana_thread_l4id)





#if !defined(_funcdef___iguana_thread_start)
#define _funcdef___iguana_thread_start
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_START_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_START_CALL_ID (2u)

static inline void iguana_thread_start (iguana_thread _service, thread_ref_t thread, uintptr_t ip, uintptr_t sp, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	register L4_Word_t r_mr4 asm("r7"); 
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_START_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			thread_ref_t thread;
			uintptr_t ip;
			uintptr_t sp;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_THREAD_START_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_START_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (3 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_START_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_START_CALL_ID) << 16) + 3 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  ((L4_Word_t)thread);
	

	r_mr3 =  ((L4_Word_t)ip);
	

	r_mr4 =  ((L4_Word_t)sp);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3), "r" (r_mr4),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_thread_start)





#if !defined(_funcdef___iguana_thread_delete)
#define _funcdef___iguana_thread_delete
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_DELETE_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_DELETE_CALL_ID (3u)

static inline void iguana_thread_delete (iguana_thread _service, thread_ref_t thread, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_DELETE_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			thread_ref_t thread;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_THREAD_DELETE_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_DELETE_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_DELETE_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_DELETE_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  ((L4_Word_t)thread);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_thread_delete)




/* Interface iguana_hardware */
#if !defined(_objdef___iguana_hardware)
#define _objdef___iguana_hardware
typedef CORBA_Object iguana_hardware;
#endif // !defined(_objdef___iguana_hardware)




#if !defined(_funcdef___iguana_hardware_register_interrupt)
#define _funcdef___iguana_hardware_register_interrupt
/* Biguuid generic code: _MAGPIE_IGUANA_HARDWARE_REGISTER_INTERRUPT_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_HARDWARE_REGISTER_INTERRUPT_CALL_ID (0u)

static inline int iguana_hardware_register_interrupt (iguana_hardware _service, hw_ref_t hardware, L4_ThreadId_t *handler, int interrupt, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	register L4_Word_t r_mr4 asm("r7"); 
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_HARDWARE_REGISTER_INTERRUPT_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			hw_ref_t hardware;
			L4_ThreadId_t handler;
			int interrupt;
		} _in;
		struct {
			long _msgtag;
			int __retval;
		} _out;
	} __MAGPIE_IGUANA_HARDWARE_REGISTER_INTERRUPT_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_HARDWARE_REGISTER_INTERRUPT_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (3 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_HARDWARE_REGISTER_INTERRUPT_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (1) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_HARDWARE_REGISTER_INTERRUPT_CALL_ID) << 16) + 3 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 25;

	r_mr2 =  ((L4_Word_t)hardware);
	

	r_mr3 =  *((L4_Word_t*)handler);
	

	r_mr4 =  ((L4_Word_t)interrupt);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3), "r" (r_mr4),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	/* Result fits in a single register. */
	return (int)r_mr1;
	
	


}
#endif // !defined(_funcdef___iguana_hardware_register_interrupt)





#if !defined(_funcdef___iguana_hardware_back_memsection)
#define _funcdef___iguana_hardware_back_memsection
/* Biguuid generic code: _MAGPIE_IGUANA_HARDWARE_BACK_MEMSECTION_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_HARDWARE_BACK_MEMSECTION_CALL_ID (1u)

static inline int iguana_hardware_back_memsection (iguana_hardware _service, hw_ref_t hardware, memsection_ref_t memsection, uintptr_t paddr, uintptr_t attributes, CORBA_Environment *_env)
{





	long _exception;
	L4_MsgTag_t _result;
	L4_Word_t _asynch_mask;

	/* NB: This union is declared volatile to work around a bug in gcc 3.3.3 */
#ifdef __cplusplus
	union _buf {
#else
	volatile union _buf {
#endif
		struct {
			long _msgtag;
			long _uuid;
			hw_ref_t hardware;
			memsection_ref_t memsection;
			uintptr_t paddr;
			uintptr_t attributes;
			
		} _in;
		struct {
			long _msgtag;
			int __retval;
			
		} _out;
	} _pack;
	/* marshal */
	
		
		
		
		_pack._in.hardware = (hw_ref_t)hardware;
	
		
		
		_pack._in.memsection = (memsection_ref_t)memsection;
	
		
		
		_pack._in.paddr = (uintptr_t)paddr;
	
		
		
		_pack._in.attributes = (uintptr_t)attributes;
	
	_pack._in._uuid = 25;

	/* invoke IPC: NB we subtract the size of _msgtag. */
	_pack._in._msgtag = ((sizeof(_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) + ((_MAGPIE_IGUANA_HARDWARE_BACK_MEMSECTION_CALL_ID) << 16);
	L4_MsgLoad((L4_Msg_t *)((void *)&_pack._in));
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	_result = L4_Call(_service);
		L4_Set_AsynchMask(_asynch_mask);

	L4_MsgStore(_result, (L4_Msg_t *)((void *)&_pack));
	

	_exception = L4_Label(_result);

	
	if (_env != 0) {
		if (!L4_IpcSucceeded(_result)) {
			*(L4_Word_t *)_env = CORBA_SYSTEM_EXCEPTION + (L4_ErrorCode() << 8);
		} else {
			*(L4_Word_t *)_env = _exception;
		}
	}

	/* Return normally. */
	return _pack._out.__retval;
	




}
#endif // !defined(_funcdef___iguana_hardware_back_memsection)




/* Interface iguana_memsection */
#if !defined(_objdef___iguana_memsection)
#define _objdef___iguana_memsection
typedef CORBA_Object iguana_memsection;
#endif // !defined(_objdef___iguana_memsection)




#if !defined(_funcdef___iguana_memsection_register_server)
#define _funcdef___iguana_memsection_register_server
/* Biguuid generic code: _MAGPIE_IGUANA_MEMSECTION_REGISTER_SERVER_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_MEMSECTION_REGISTER_SERVER_CALL_ID (0u)

static inline int iguana_memsection_register_server (iguana_memsection _service, memsection_ref_t memsection, thread_ref_t thread, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_MEMSECTION_REGISTER_SERVER_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			memsection_ref_t memsection;
			thread_ref_t thread;
		} _in;
		struct {
			long _msgtag;
			int __retval;
		} _out;
	} __MAGPIE_IGUANA_MEMSECTION_REGISTER_SERVER_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_MEMSECTION_REGISTER_SERVER_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (2 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_MEMSECTION_REGISTER_SERVER_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (1) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_MEMSECTION_REGISTER_SERVER_CALL_ID) << 16) + 2 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 26;

	r_mr2 =  ((L4_Word_t)memsection);
	

	r_mr3 =  ((L4_Word_t)thread);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	/* Result fits in a single register. */
	return (int)r_mr1;
	
	


}
#endif // !defined(_funcdef___iguana_memsection_register_server)





#if !defined(_funcdef___iguana_memsection_lookup)
#define _funcdef___iguana_memsection_lookup
/* Biguuid generic code: _MAGPIE_IGUANA_MEMSECTION_LOOKUP_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_MEMSECTION_LOOKUP_CALL_ID (1u)

static inline memsection_ref_t iguana_memsection_lookup (iguana_memsection _service, uintptr_t address, thread_ref_t *server, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_MEMSECTION_LOOKUP_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			uintptr_t address;
		} _in;
		struct {
			long _msgtag;
			thread_ref_t server;
			memsection_ref_t __retval;
		} _out;
	} __MAGPIE_IGUANA_MEMSECTION_LOOKUP_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_MEMSECTION_LOOKUP_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_MEMSECTION_LOOKUP_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (2) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_MEMSECTION_LOOKUP_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 26;

	r_mr2 =  ((L4_Word_t)address);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1), "=r" (r_mr2),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	*server = (thread_ref_t)r_mr1;
	
	
	/* Result fits in a single register. */
	return (memsection_ref_t)r_mr2;
	
	


}
#endif // !defined(_funcdef___iguana_memsection_lookup)





#if !defined(_funcdef___iguana_memsection_delete)
#define _funcdef___iguana_memsection_delete
/* Biguuid generic code: _MAGPIE_IGUANA_MEMSECTION_DELETE_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_MEMSECTION_DELETE_CALL_ID (2u)

static inline void iguana_memsection_delete (iguana_memsection _service, memsection_ref_t thread, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_MEMSECTION_DELETE_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			memsection_ref_t thread;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_MEMSECTION_DELETE_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_MEMSECTION_DELETE_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_MEMSECTION_DELETE_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_MEMSECTION_DELETE_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 26;

	r_mr2 =  ((L4_Word_t)thread);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_memsection_delete)




/* Interface iguana_session */
#if !defined(_objdef___iguana_session)
#define _objdef___iguana_session
typedef CORBA_Object iguana_session;
#endif // !defined(_objdef___iguana_session)




#if !defined(_funcdef___iguana_session_delete)
#define _funcdef___iguana_session_delete
/* Biguuid generic code: _MAGPIE_IGUANA_SESSION_DELETE_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_SESSION_DELETE_CALL_ID (0u)

static inline void iguana_session_delete (iguana_session _service, session_ref_t session, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_SESSION_DELETE_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			session_ref_t session;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_SESSION_DELETE_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_SESSION_DELETE_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_SESSION_DELETE_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_SESSION_DELETE_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 27;

	r_mr2 =  ((L4_Word_t)session);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_session_delete)





#if !defined(_funcdef___iguana_session_add_buffer)
#define _funcdef___iguana_session_add_buffer
/* Biguuid generic code: _MAGPIE_IGUANA_SESSION_ADD_BUFFER_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_SESSION_ADD_BUFFER_CALL_ID (1u)

static inline void iguana_session_add_buffer (iguana_session _service, session_ref_t session, objref_t call_buf, objref_t return_buf, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	register L4_Word_t r_mr4 asm("r7"); 
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_SESSION_ADD_BUFFER_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			session_ref_t session;
			objref_t call_buf;
			objref_t return_buf;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_SESSION_ADD_BUFFER_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_SESSION_ADD_BUFFER_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (3 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_SESSION_ADD_BUFFER_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_SESSION_ADD_BUFFER_CALL_ID) << 16) + 3 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 27;

	r_mr2 =  ((L4_Word_t)session);
	

	r_mr3 =  ((L4_Word_t)call_buf);
	

	r_mr4 =  ((L4_Word_t)return_buf);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
		_asynch_mask = L4_Get_AsynchMask();
	L4_Set_AsynchMask(0);

	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3), "r" (r_mr4),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
		L4_Set_AsynchMask(_asynch_mask);

	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_session_add_buffer)





#endif //__-__
